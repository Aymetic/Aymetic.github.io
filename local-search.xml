<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++实现的几种斐波那契数列算法</title>
    <link href="/post/57a23e5f.html"/>
    <url>/post/57a23e5f.html</url>
    
    <content type="html"><![CDATA[<p>作为算法课的练手项目，斐波那契数列的生成再合适不过了。最重要的就是蛮力法，可以拿来求解斐波那契数列并可以进一步的优化求解。</p><h2 id="经典的迭代和递归"><a href="#经典的迭代和递归" class="headerlink" title="经典的迭代和递归"></a>经典的迭代和递归</h2><p>斐波那契数列有关十分明显的特点，那是：前面相邻两项之和，构成了后一项。即$F(n)=F(n-1)+F(n-2), F(0)=0, F(1)=F(2)=1$, 推导下去$F(3)=2, F(4)=3, F(5)=5…$由此可以很容易得到下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//递归算法</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Recursion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">return</span> Recursion(n - <span class="hljs-number">1</span>) + Recursion(n - <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-comment">//迭代算法</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Iteration</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> *F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> n;<br>    F[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    F[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>        F[i] = F[i - <span class="hljs-number">1</span>] + F[i - <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">int</span> result = F[n];<br>    <span class="hljs-keyword">delete</span>[] F;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>使用上面的方式求解第n项斐波那契数列的时间复杂度为<strong>O(n)</strong>,也就是说，时间复杂度随着n的增长而线性增长。</p></blockquote><h2 id="用矩阵乘法做优化"><a href="#用矩阵乘法做优化" class="headerlink" title="用矩阵乘法做优化"></a>用矩阵乘法做优化</h2><h3 id="矩阵的概念"><a href="#矩阵的概念" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h3><p>在数学中，矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合，最早来自于方程组的系数及常数所构成的方阵。</p><p>矩阵相乘：矩阵相乘最重要的方法是一般矩阵乘积。它只有在第一个矩阵的列数（column）和第二个矩阵的行数（row）相同时才有意义。一般单指矩阵乘积时，指的便是一般矩阵乘积。一个m×n的矩阵就是m×n个数排成m行n列的一个数阵。由于它把许多数据紧凑的集中到了一起，所以有时候可以简便地表示一些复杂的模型。</p><p>设A为m*p的矩阵，B为p*n的矩阵，那么称m*n的矩阵C为矩阵A与B的乘积，记作C=AB</p><h3 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h3><p>前面提到说从第三项开始，往后的每一项都是前面两项之和，即$F(n)=F(n-1)+F(n-2), n≥3$. 我们将数列的相邻的两项表示为下列矩阵<br>$$<br>\begin{bmatrix}<br>F(n+1)&amp;F(n)\<br>F(n)&amp;F(n-1)\<br>\end{bmatrix}<br>=<br>{\begin{bmatrix}<br>1&amp;1\<br>1&amp;0\<br>\end{bmatrix}}^n<br>$$<br>这里有个需要注意的地方就是如果要求的幂是2的幂次数还比较好算，如果不是的话我们就需要对其做一些判断和处理。判断要求的幂的二进制数和1相与，查看结果是否为1，如果为1说明这个数不是2的整数次幂，需要一次一次的求矩阵的幂，直到这个数是2的整数次幂。</p><p>上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//矩阵乘法</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; MatrixMulti(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;a, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;b)<br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    res.push_back(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>    res.push_back(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; ++j)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span>; ++k)<br>                res[i][j] += a[i][k] * b[k][j];<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Matrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; x;<br>    result.push_back(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);<br>    result.push_back(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<br>    x.push_back(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);<br>    x.push_back(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);<br>    x = MatrixMulti(result,x);<br><br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">//取n的二进制的最后一位和1做与运算，如果最后一位是1，则进入if体内部</span><br>            result = MatrixMulti(result,x); <span class="hljs-comment">//如果在该位置n的二进制为1，则计算result和x矩阵</span><br>        x = MatrixMulti(x,x); <span class="hljs-comment">//x矩阵相乘，相当于初始x矩阵的幂*2</span><br>        <span class="hljs-comment">//printVector(x);</span><br>        n /= <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">//最后获取到的二阶矩阵的[0][1]即F(n)的值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>使用上面的方式求解第n项斐波那契数列的时间复杂度是<strong>O(logn)</strong></p></blockquote><h2 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h2><p>公式法没啥好说的，直接上个求解斐波那契数列的公式：<br>$$<br>F(n)=\frac {1}{\sqrt 5}[{(\frac {1+\sqrt 5}{2})}^n-{(\frac {1-\sqrt 5}{2})}^n]<br>$$<br>上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Formula</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1.0</span> / <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5</span>)) * (<span class="hljs-built_in">pow</span>(((<span class="hljs-number">1</span> + <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5</span>)) / <span class="hljs-number">2.0</span>), n) - (<span class="hljs-number">-1.0</span> / <span class="hljs-built_in">pow</span>(((<span class="hljs-number">1</span> + <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5</span>)) / <span class="hljs-number">2.0</span>), n)));<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>使用上面的方式求解第n项斐波那契数列的时间复杂度是<strong>O(1)</strong></p></blockquote><h2 id="优化迭代算法"><a href="#优化迭代算法" class="headerlink" title="优化迭代算法"></a>优化迭代算法</h2><p>此算法将迭代算法从O(n)优化成O(1)，且代码思路非常简单！</p><p>直接上代码，一看就明白</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BetterIteration</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            a = a + b;<br>        <span class="hljs-keyword">else</span><br>            b = a + b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>使用上面的方式求解第n项斐波那契数列的时间复杂度是<strong>O(1)</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>抛开最前面的暴力递归和迭代，思路过于简单且效率低下，剩下的都是经过优化后的算法。由此可见，蛮力法往往是我们首先想到的开思路的算法。但是经过我们一步一步的演化分析，最终我们得到了复杂度为常数的算法！这是非常令人振奋的事！</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>郑州之旅</title>
    <link href="/post/d9019c8f.html"/>
    <url>/post/d9019c8f.html</url>
    
    <content type="html"><![CDATA[<p>记不清哪天开始讨论去郑州的了。从等待火车票开售到等待见面后的激动，中间不知经历了多少个难熬的夜晚。但是！这一天终于快到了，老规矩，先上倒计时！</p><iframe src="../myPages/A trip to Zhengzhou/index.html" scrolling="yes" frameborder=0 width=100% height=50> </iframe><p>待更新~</p>]]></content>
    
    
    
    <tags>
      
      <tag>情侣之间的记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年2月8日总结</title>
    <link href="/post/80e9c118.html"/>
    <url>/post/80e9c118.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="你是谁？不知道密码请关掉网页." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="21f7552d23549732c29f7c90b357e1571025c1ae216d9a9cc5ad3d876246e380">ecc9edad14c3285aea2485150bb2aad0af9957d7882f84fb1d3161db0ce40529699f22effad59aaeb46729ef607460abd0be3a68220867e68aa58a2a70ff0aff306d1d2f8a0942a1088ae463cc9bc53687c6574aec7a60e503998b82b82b635ec28fa35346fa1cf6c0fe248ea971402dc0119451c5b7dd45d37b54ee7708f1fa66d0217f8c3df3a85b4c6259f3d758f22e13dbe7531f6e5fa804d9362d059f8b4a2587be0e645df91f2351c063c4413044a911cde994b45fda3323db329c0b1c683a50afb48b8598e70c3670bb489098dce57d3d94b7367a1964f9fca36902f7b0cec543152edbea60422829e08dd4b2b94e8e711341e9fcbe8d13dd81b9de66b652faf7a0a9b38594b76bcacfc46968aa8c4ee5f70f5c269db5844d2f32a70d9de1e0a3a9ddb1fc99336b351c949b81fd2e30bfd36617b24a4b7d8f6d9539d77fed23faaddb31dcaee28e1c532ee09dd614da0b82439c838add60b2c4cec1e83fa627c05da954218499fa440024dd6f3f00c1a5e1d6d0a78a03382dd9503414fa5d104a508e5ad5f4d51070cbc64d059957eb1d6f7794400044c62edf9df55ea9ae55652186234266fbf0c7a5af34e33b7791cbbe63bec1010622acff23e9df71dc04a3ecb9d035de05a840a53141ceb5e88eec864020ff21434d1d7c724182b62c41f9f668ad78282884f95e8e346ba1474716b9d79443483a979ef849ce405af0c66fd09ddfd2dc5be873446430c21e9ea5fb62e9e1fbaf563d4f6e2e59fa2f7378061bb71db1548fd32bcc46f86fc42b0fbb300b89dc7f51102790895358f365bb2d41251c8b3f75d45e32f648be892e6e39878a5f316123bb640e0369fd47e11ffb073ba83ae331e5bed79170f8a8bdd6f451a9293e2b23bf27e98e45a8510e75b0fec1e23ec6041d1031b89281df102f09dfb312cd6af2c9c641cc156afd30e30321d27ee49d44b820b136ca23ee079fa9fa13d3701670a28db9e2ef9860522be4fa354dff338bc4f907fe7efd941c26f69e28a108f443d306b2d70b9e9eaa6ddbe34d10430f14d32376bbfdcea75c65f44a18daca708cdca4c83d72ebece27fb39a93df1b680f944bac82d749f455dcfb33df33825283e2fb1eacfa50aab1e44c54188064bd1ca06d1f8053f0755f04891526f9cbd8ddbe392dd8cfa74df71f549db87bf1be2eb5097ba0f4aa3fcb20d790e55f98b4f75aba72f32fd3b32116c6b891cef4a7102898cb5c82b7a0d74f118026d6385e3762da8515da668eeb6ad735538a94f3e44246ddad68da5bcff14c384dee34702a0b9d75cbd1d855b579e95bedbf08692fe9fcd065aba9660b4d56a3002e5b59a0f9b7c1dd584ae3f6e77e39426df347ae18acc255e635d60a53c1e678232792d3bde99a6982cf5c1112dec400deb9ac806094f120b7a9612ab168db638e28832dac2430f745a6dcbf4f67bc39238c4186fb3c98b9666e707146701b1ad999a41de4ab1ce371685943243a0b9a68cf44daee7db698133d6a4da8f077a104055e8c214bcff3f94d256571b1aa3f979f24eea13f1dacefc7660105507a94897dfa92d099ef9ba5cc46d3c4479180587e4b0d4d5829ab0cb639efc184c597828ed29b19b5072d80abb4826f5ab6c4a981ffcce935a8ce2f348fa3860d0432522a06cf8754c5fdaf6ddd122c3103a1edd7cb0ccf0df0dc3a38e0b6251f4ab33ace7e3368d87cd057ce3a9f53be357cd8a3ed7d882bc6f3089aa5f0597478cedb82e05a762689fa42c6e7fe722824fde553a55932b83975eecd606e095f5a9985d74573054c1176a8c36920fa7fb166ccb422071df922085c4811c8eeec1c0356bd1b4591f21f50e3ea1356915be84266d2f8f813c1bd33d396908ee2163f9a75da87dfcdff1b5fc5bf9e479f7eb3d61cefa58f03e772c57c9b9aecd3ab39beae498ec0e46782594444f25ccbddb4d09515ebce3183774f6860126d1d05a03262947adda1bdc8487c8aee64a9cf490bb5d64a75305089cc4474f29c100b9c0fafeb464dedf1d7b727d0d37abf461e3bf43cc66f4dab212a5b86dddabee600a82e6403444843186f45becb9f1556c6fc5fd7639a336e2b2dbd064167b9f9035cf6ac4f01ec105604e86122f7fd02b9c9130dcd89282d4b86a331</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">在这里输入你知道的密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>情侣之间的记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/post/4a17b156.html"/>
    <url>/post/4a17b156.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
